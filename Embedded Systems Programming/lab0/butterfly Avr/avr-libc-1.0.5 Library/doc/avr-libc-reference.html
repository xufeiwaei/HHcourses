<HTML>
<HEAD>
<TITLE>AVR libc function reference</TITLE>
<style type="text/css">
<!--
.hell {  background-color: #CCCCCC}
.dunkel {  background-color: #AAAAAA}
table {  background-color: #666666}
a:hover {  color: #0000FF; text-decoration: underline}
a {  color: #000099; text-decoration: none}
-->
</style>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<center>
    <H1>AVR libc function reference</H1> 2002/01/28
</CENTER>
<HR>

<P>
This file gives an overview of the C library functions implemented in the avr-libc 
standard library for the Atmel AVR microcontroller family.
</P>
<P>
As of the writing of this reference, the current version of avr-libc was 
20020115.
</P>
<P>
avr-libc is maintained by Marek Michalkiewicz &lt;marekm@linux.org.pl&gt;.
</P>
<P>
This document is written by Enno Luebbers &lt;luebbers@users.sourceforge.net&gt;. I do 
not take any responsibility about what happens if you use the information in 
this reference. You are on your own. :) Formally that means:
</P>
<P>
<B>This document is distributed in the hope that it will be useful, but WITHOUT 
ANY WARRANTY.  ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY DISCLAIMED.  This 
includes but is not limited to warranties of MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE.</B>
</P>

<P>
Documentation for most of the functions that are not hardware specific to the 
AVR architecture (like I/O ports or interrupt handlers) can be found in the 
Linux manpages.
</P>

<P>Thanks go to J&ouml;rg Wunsch for pointing me to several errors in previous 
  versions of this reference and for including it in the FreeBSD Port of the avr-libc. 
  Also thanks to Jochen Pernsteiner for his explanation of strlwr() and to Peter 
  N Lewis for his help on SIGNAL() and INTERRUPT(). And of course thanks to 
  Marek Michalkiewicz for including this document in his avr-libc distribution.</P>
<HR>

<H2>Function list by Header files</H2>
<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A HREF="#ctype.h">ctype.h</A></TD>
    <TD class="hell">Character type test functions</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#eeprom.h">eeprom.h</A></TD>
    <TD class="dunkel">EEPROM access functions</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#errno.h">errno.h</A></TD>
    <TD class="hell">Error handling</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#ina90.h">ina90.h</A></TD>
    <TD class="dunkel">Compatibility header for IAR C</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#interrupt.h">interrupt.h</A></TD>
    <TD class="hell">Interrupt handling routines</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#inttypes.h">inttypes.h</A></TD>
    <TD class="dunkel">Defines for different int data types</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#io.h">io.h</A></TD>
    <TD class="hell">Includes the correct ioXXX.h header</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#io.h">io.h</A></TD>
    <TD class="dunkel">Includes other I/O-Headers</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#ioXXX.h">ioXXX.h</A></TD>
    <TD class="hell">I/O-Defines for various AVR microcontrollers</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#sfr_defs.h">sfr_defs.h</A></TD>
    <TD class="dunkel">Several macros for I/O access</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#math.h">math.h</A></TD>
    <TD class="hell">Various mathematical functions</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#pgmspace.h">pgmspace.h</A></TD>
    <TD class="dunkel">Compatibility header for IAR C</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#progmem.h">progmem.h</A></TD>
    <TD class="hell">Alias for pgmspace.h</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#setjmp.h">setjmp.h</A></TD>
    <TD class="dunkel">Provides functions for long jumps</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#sig-avr.h">sig-avr.h</A></TD>
    <TD class="hell">AVR interrupt and signal handling</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#signal.h">signal.h</A></TD>
    <TD class="dunkel">Alias for sig-avr.h. Should no longer be used.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#stdlib.h">stdlib.h</A></TD>
    <TD class="hell">Miscellaneous routines</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#string.h">string.h</A></TD>
    <TD class="dunkel">String manipulation functions</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#timer.h">timer.h</A></TD>
    <TD class="hell">Timer control functions</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A HREF="#twi.h">twi.h</A></TD>
    <TD class="dunkel">ATmega163 specific defines</TD>
  </TR>
  <TR> 
    <TD class="hell"><A HREF="#wdt.h">wdt.h</A></TD>
    <TD class="hell">Watchdog Timer control functions</TD>
  </TR>
</TABLE>


<HR>

<H2>Alphabetical function list</H2>

<p>
<tt>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#abort">abort();</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#acos">acos( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#asin">asin( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#atan">atan( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">long</TD>
    <TD class="hell"><A HREF="#atoi">atoi( char *p );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">long</TD>
    <TD class="dunkel"><A HREF="#atol">atol( char *p );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#bit_is_clear">bit_is_clear( port, bit );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#bit_is_set">bit_is_set( port, bit );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#bsearch">bsearch(const void *key, const void *base, 
      size_t nmemb,</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#_BV">_BV( x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#cbi">cbi( port, bit );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#ceil">ceil( doublce x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#cli">cli();</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#cos">cos( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#cosh">cosh( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">div_t</TD>
    <TD class="dunkel"><A HREF="#div">div( int x, int y );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#eeprom_is_ready">eeprom_is_ready()</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">unsigned char</TD>
    <TD class="dunkel"><A HREF="#eeprom_rb">eeprom_rb(unsigned int addr);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#eeprom_read_block">eeprom_read_block(void *buf, 
      unsigned int addr, size_t n);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">unsigned int</TD>
    <TD class="dunkel"><A HREF="#eeprom_rw">eeprom_rw(unsigned int addr);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#eeprom_wb">eeprom_wb(unsigned int addr, unsigned 
      char val);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#enable_external_int">enable_external_int( unsigned 
      char ints );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#errno">errno();</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#exp">exp( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#fabs">fabs( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#floor">floor( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#fmod">fmod( double x, double y );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#free">free( void *ptr );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#frexp">frexp( double x, int *exp );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#inb">inb( port );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#INTERRUPT">INTERRUPT( signame );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#inverse">inverse( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#isalnum">isalnum(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#isalpha">isalpha(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#isascii">isascii(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#isblank">isblank(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#iscntrl">iscntrl(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#isdigit">isdigit(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#isgraph">isgraph(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#islower">islower(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#isprint">isprint(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#ispunct">ispunct(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#isspace">isspace(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#isupper">isupper(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#isxdigit">isxdigit(int __c);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">char</TD>
    <TD class="dunkel"><A HREF="#itoa">itoa( int value, char *string, int radix 
      ) {</A></TD>
  </TR>
  <TR> 
    <TD class="hell">long</TD>
    <TD class="hell"><A HREF="#labs">labs( long x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#ldexp">ldexp( double x, int exp );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">ldiv_t</TD>
    <TD class="hell"><A HREF="#ldiv">ldiv( lomg x, long y );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#log">log( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#log10">log10( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#longjmp">longjmp( jmp_buf env, int val );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#loop_until_bit_is_clear">loop_until_bit_is_clear( 
      port, bit );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#loop_until_bit_is_set">loop_until_bit_ist_set( 
      port, bit );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">char *</TD>
    <TD class="hell"><A HREF="#ltoa">ltoa( long val, char *s, int radix );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#malloc">malloc( size_t size );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#memchr">memchr( void *s, char c, size_t n );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#memcmp">memcmp( const void *s1, const void *s2, 
      size_t n );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#memcpy">memcpy( void *to, void *from, size_t n 
      );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#memmove">memmove( void *to, void *from, size_t 
      n );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#memset">memset( void *s, int c, size_t n );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#modf">modf( double x, double *iptr );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#outb">outb( port, value );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#parity_even_bit">parity_even_bit( val );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#pow">pow( double x, double y );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#qsort">qsort(void *base, size_t nmemb, size_t 
      size, __compar_fn_t compar);</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#sbi">sbi( port, bit );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#sei">sei();</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#setjmp">setjmp( jmp_buf env );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_ADC">SIG_ADC(</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_COMPARATOR">SIG_COMPARATOR(</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_EEPROM">SIG_EEPROM(</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_INPUT_CAPTURE1">SIG_INPUT_CAPTURE1(</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">&nbsp;</TD>
    <TD class="dunkel"><A HREF="#SIG_INTERRUPT">SIG_INTERRUPT0 through SIG_INTERRUPT7</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_OUTPUT_COMPARE0">SIG_OUTPUT_COMPARE0</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_OUTPUT_COMPARE1A">SIG_OUTPUT_COMPARE1A</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_OUTPUT_COMPARE1B">SIG_OUTPUT_COMPARE1B</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_OUTPUT_COMPARE2">SIG_OUTPUT_COMPARE2</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_OVERFLOW0">SIG_OVERFLOW0</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_OVERFLOW1">SIG_OVERFLOW1</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_OVERFLOW2">SIG_OVERFLOW2</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_SPI">SIG_SPI</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_UART1_DATA">SIG_UART1_DATA</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_UART1_RECV">SIG_UART1_RECV</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_UART1_TRANS">SIG_UART1_TRANS</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_UART_DATA">SIG_UART_DATA</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIG_UART_RECV">SIG_UART_RECV</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#SIG_UART_TRANS">SIG_UART_TRANS</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#SIGNAL">SIGNAL( signame );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#sin">sin( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#sinh">sinh( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#sqrt">sqrt( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#square">square( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern int</TD>
    <TD class="dunkel"><A HREF="#strcasecmp">strcasecmp(const char *s1, const 
      char *s2);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">char</TD>
    <TD class="hell"><A HREF="#strcat">strcat( char *dest, char *src );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">char</TD>
    <TD class="dunkel"><A HREF="#strchr">strchr( const char *s, int c );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#strcmp">strcmp( const char *s1, const char* s2 
      );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">char</TD>
    <TD class="dunkel"><A HREF="#strcpy">strcpy( char *dest, char *src );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#strdupa">strdupa( s );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">size_t</TD>
    <TD class="dunkel"><A HREF="#strlen">strlen( char *s );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">extern char</TD>
    <TD class="hell"><A HREF="#strlwr">strlwr(char *);</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern int</TD>
    <TD class="dunkel"><A HREF="#strncasecmp">strncasecmp(const char *, const 
      char *, size_t);</A></TD>
  </TR>
  <TR> 
    <TD class="hell">char</TD>
    <TD class="hell"><A HREF="#strncat">strncat( char *dest, char *src, size_t 
      n );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#strncmp">strncmp( const char *s1, const char* 
      s2, size_t n );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">char</TD>
    <TD class="hell"><A HREF="#strncpy">strncpy( char *dest, char *src, size_t 
      n );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#strndupa">strndupa( s, n );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">size_t</TD>
    <TD class="hell"><A HREF="#strnlen">strnlen( const char *s, size_t maxlen 
      );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">char</TD>
    <TD class="dunkel"><A HREF="#strrchr">strrchr( const char *s, int c );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">extern char</TD>
    <TD class="hell"><A HREF="#strrev">strrev( char *s1 );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern char</TD>
    <TD class="dunkel"><A HREF="#strstr">strstr( const char *haystack, const char 
      *needle );</A></TD>
  </TR>
<!-- Duplicate
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#strtod">strtod( char *, char ** );</A></TD>
  </TR> 
-->
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#strtod">strtod( const char *s, char **endptr 
      );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">long</TD>
    <TD class="dunkel"><A HREF="#strtol">strtol( const char *nptr, char **endptr, 
      int base );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">unsigned long</TD>
    <TD class="hell"><A HREF="#strtoul">strtoul( const char *nptr, char **endptr, 
      int base );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern char</TD>
    <TD class="dunkel"><A HREF="#strupr">strupr( char * );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">double</TD>
    <TD class="hell"><A HREF="#tan">tan( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">double</TD>
    <TD class="dunkel"><A HREF="#tanh">tanh( double x );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#timer0_source">timer0_source( unsigned int src 
      );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#timer0_start">timer0_start();</A></TD>
  </TR>
  <TR> 
    <TD class="hell">void</TD>
    <TD class="hell"><A HREF="#timer0_stop">timer0_stop();</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">void</TD>
    <TD class="dunkel"><A HREF="#timer_enable_int">timer_enable_int( unsigned char 
      ints );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#toascii">toascii( int __c );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">int</TD>
    <TD class="dunkel"><A HREF="#tolower">tolower( int __c );</A></TD>
  </TR>
  <TR> 
    <TD class="hell">int</TD>
    <TD class="hell"><A HREF="#toupper">toupper( int __c );</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel">char *</TD>
    <TD class="dunkel"><A HREF="#ultoa">ultoa( unsigned long val, char *s, int radix );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#wdt_disable">wdt_disable();</A></TD>
  </TR>
  <TR> 
    <TD class="dunkel"></TD>
    <TD class="dunkel"><A HREF="#wdt_enable">wdt_enable( timeout );</A></TD>
  </TR>
  <TR> 
    <TD class="hell"></TD>
    <TD class="hell"><A HREF="#wdt_reset">wdt_reset();</A></TD>
  </TR>
</TABLE>

</tt>
<p></p>




<HR>

<A NAME="ctype.h"><H3>ctype.h</H3></A>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="isalnum"></A>int isalnum(int __c);</TD>
    <TD class="hell">Returns 1 if c is alphanumeric, otherwise 0.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="isalpha"></A>int isalpha(int __c);</TD>
    <TD class="dunkel">Returns 1 if c is alphabetic, otherwise 0.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="isascii"></A>int isascii(int __c);</TD>
    <TD class="hell">Returns 1 if c is contained in the 7bit ASCII, otherwise 
      0.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="iscntrl"></A>int iscntrl(int __c);</TD>
    <TD class="dunkel">Returns 1 if c is a control character, otherwise 0.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="isdigit"></A>int isdigit(int __c);</TD>
    <TD class="hell">Returns 1 if c is a digit, otherwise 0.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="isgraph"></A>int isgraph(int __c);</TD>
    <TD class="dunkel">Returns 1 if c is printable (excluding space), otherwise 
      0.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="islower"></A>int islower(int __c);</TD>
    <TD class="hell">Returns 1 if c is a lower case alphabetic character, otherwise 
      0.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="isprint"></A>int isprint(int __c);</TD>
    <TD class="dunkel">Returns 1 if c is printable (including space), otherwise 
      0.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="ispunct"></A>int ispunct(int __c);</TD>
    <TD class="hell">Returns 1 if c is a puntuation character, otherwise 0.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="isspace"></A>int isspace(int __c);</TD>
    <TD class="dunkel">Returns 1 if c is one of space, '\n', '\f', '\r', '\t', 
      '\v', otherwise 0.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="isupper"></A>int isupper(int __c);</TD>
    <TD class="hell">Returns 1 if c is an upper case alphabetic character, otherwise 
      0.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="isxdigit"></A>int isxdigit(int __c);</TD>
    <TD class="dunkel">Returns 1 if c is a hexadecimal digit (0-9 or A-F), otherwise 
      0.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="isblank"></A>int isblank(int __c);</TD>
    <TD class="hell">Returns 1 if c is a blank character, otherwise 
      0.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="toascii"></A>int toascii(int __c);</TD>
    <TD class="dunkel">Converts c to a 7bit ASCII character.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="tolower"></A>int tolower(int __c);</TD>
    <TD class="hell">Converts c to lower case.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="toupper"></A>int toupper(int __c);</TD>
    <TD class="dunkel">Converts c to upper case.</TD>
  </TR>
</TABLE>

<HR>

<A NAME="eeprom.h"><H3>eeprom.h</H3></A>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="eeprom_is_ready"></A>int eeprom_is_ready() 
      /* Macro */</TD>
    <TD class="hell">Returns != 0 if the EEPROM is ready (bit EEWE in register 
      EECR is 0).</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="eeprom_rb"></A>unsigned char eeprom_rb(unsigned 
      int addr);</TD>
    <TD class="dunkel">Read one byte from EEPROM address 'addr'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="eeprom_rw"></A>unsigned int eeprom_rw(unsigned int 
      addr);</TD>
    <TD class="hell">Read one 16-bit word (little endian) from EEPROM address 
      'addr'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="eeprom_wb"></A>void eeprom_wb(unsigned int addr, 
      unsigned char val);</TD>
    <TD class="dunkel">Write a byte 'val' to EEPROM address 'addr'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="eeprom_read_block"></A>void eeprom_read_block(void 
      *buf, unsigned int addr, size_t n);</TD>
    <TD class="hell">Read a block of 'size' bytes from EEPROM address 'addr' to 
      'buf'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">_EEPUT(addr, val) eeprom_wb(addr, val)<BR>
      _EEGET(var, addr) (var) = eeprom_rb(addr)</TD>
    <TD class="dunkel">Compatibility macros for IAR C compatibility.</TD>
  </TR>
</TABLE>

<HR>

<A NAME="errno.h"><H3>errno.h</H3></A>
<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="errno"></A>int errno;</TD>
    <TD class="hell">Holds the system-wide error code.</TD>
  </TR>
</TABLE>

<HR>

<A NAME="ina90.h"><H3>ina90.h</H3></A>

<P>
This header file contains some compatibility functions and macros to make 
porting applications from the IAR C compiler to avr-gcc easier. Since you wouldn't 
use it for writing new applications, there's no need for documentation here (lazy 
me).
</P>

<HR>

<A NAME="interrupt.h"><H3>interrupt.h</H3></A>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="sei"></A>sei();</TD>
    <TD class="hell">Enable Interrupts. Macro.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="cli"></A>cli();</TD>
    <TD class="dunkel">Disable Interrupts. Macro.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="enable_external_int"></A>void enable_external_int( 
      unsigned char ints );</TD>
    <TD class="hell">Write 'ints' to the EIMSK or GIMSK register, depending on 
      whether EIMSK or GIMSK is defined.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="timer_enable_int"></A>void timer_enable_int( unsigned 
      char ints );</TD>
    <TD class="dunkel">Write 'ints' to the TIMSK register, if TIMSK is defined.</TD>
  </TR>
</TABLE>

<HR>

<A NAME="inttypes.h"><H3>inttypes.h</H3></A>

<P>
Defines the following types:
</P>

<TT>typedef signed char int8_t;<BR>
typedef unsigned char uint8_t;<BR>
<BR>
typedef int int16_t;<BR>
typedef unsigned int uint16_t;<BR>
<BR>
typedef long int32_t;<BR>
typedef unsigned long uint32_t;<BR>
<BR>
typedef long long int64_t;<BR>
typedef unsigned long long uint64_t;<BR>
<BR>
typedef int16_t intptr_t;<BR>
typedef uint16_t uintptr_t;<BR>
</TT>
<P>
Be careful with the <TT>-mint8</TT> option, though.
</P>


<HR>

<A NAME="io.h"><H3>io.h</H3></A>

<P>
Automagically includes the <A HREF="#ioXXX.h">ioXXX.h</A> header file for the 
target AVR microcontroller.
</P>


<HR>

<A NAME="ioXXX.h"><H3>ioXXX.h</H3></A>

<P>
I/O-register definitions for the XXX MCU. Refer to the specific datasheet for a 
description of the registers and their functions.
</P>


<HR>

<A NAME="sfr_defs.h"><H3>sfr_defs.h</H3></A>


<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="_BV"></A>_BV( x );</TD>
    <TD class="hell">Returns the value of bit x (BitValue). Essentially an (1 
      << x). Macro.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="inb"></A>inb( port );</TD>
    <TD class="dunkel">Read byte from port 'port'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="outb"></A>outb( port, value );</TD>
    <TD class="hell">Write 'value' to 'port'. Macro.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="cbi"></A>cbi( port, bit );</TD>
    <TD class="dunkel">Clear bit 'bit' in port 'port'. Macro.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="sbi"></A>sbi( port, bit );</TD>
    <TD class="hell">Set bit 'bit' in port 'port'. Macro. Don't ask.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="bit_is_set"></A>bit_is_set( port, bit );</TD>
    <TD class="dunkel">Returns something != 0, if bit 'bit' in 'port' is set, 
      otherwise 0. Macro.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="bit_is_clear"></A>bit_is_clear( port, bit );</TD>
    <TD class="hell">Returns something != 0, if bit 'bit' in 'port' is clear, 
      otherwise 0. Macro.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="loop_until_bit_is_set"></A>loop_until_bit_ist_set( 
      port, bit );</TD>
    <TD class="dunkel">Loops until bit 'bit' in port 'port' is set. Macro.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="loop_until_bit_is_clear"></A>loop_until_bit_is_clear( 
      port, bit );</TD>
    <TD class="hell">Loops until bit 'bit' in port 'port' is clear. Macro.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="parity_even_bit"></A>parity_even_bit( val );</TD>
    <TD class="dunkel">Returns 0 if the byte 'val' has an even number of ones,
      1 otherwise. Macro.</TD>
    </TD>
  </TR>
</TABLE>


<HR>

<A NAME="math.h"><H3>math.h</H3></A>

<P>
Constants:
</P>
<TT>M_PI = 3.141592653589793238462643</TT><BR>
Pi.<BR>
<TT>M_SQRT2 = 1.4142135623730950488016887</TT><BR>
The square root of two.<BR>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="cos"></A>double cos( double x );</TD>
    <TD class="hell">Returns the cosine of x.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="fabs"></A>double fabs( double x );</TD>
    <TD class="dunkel">Returns the absolute value of x.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="fmod"></A>double fmod( double x, double y );</TD>
    <TD class="hell">Returns the floating point remainder of x/y.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="modf"></A>double modf( double x, double *iptr 
      );</TD>
    <TD class="dunkel">Returns the fractional part of x and stores the integral 
      part in *iptr.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="sin"></A>double sin( double x );</TD>
    <TD class="hell">Returns the sine of x.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="sqrt"></A>double sqrt( double x );</TD>
    <TD class="dunkel">Returns the square root of x.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="tan"></A>double tan( double x );</TD>
    <TD class="hell">Returns the tangens of x.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="floor"></A>double floor( double x );</TD>
    <TD class="dunkel">Returns the biggest integer smaller than x.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="ceil"></A>double ceil( doublce x );</TD>
    <TD class="hell">Returns the smallest integer bigger than x.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="frexp"></A>double frexp( double x, int *exp );</TD>
    <TD class="dunkel">Splits x into a normalized fraction, which is returned, 
      and an exponent, which is stored in *exp.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="ldexp"></A>double ldexp( double x, int exp );</TD>
    <TD class="hell">Returns the result of x*2^exp.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="exp"></A>double exp( double x );</TD>
    <TD class="dunkel">Returns e^x;</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="cosh"></A>double cosh( double x );</TD>
    <TD class="hell">Returns the hyperbolic cosine of x.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="sinh"></A>double sinh( double x );</TD>
    <TD class="dunkel">Returns the hyperbolic sine of x.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="tanh"></A>double tanh( double x );</TD>
    <TD class="hell">Returns the hyperbolc tangens of x.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="acos"></A>double acos( double x );</TD>
    <TD class="dunkel">Returns the arc cosine of x.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="asin"></A>double asin( double x );</TD>
    <TD class="hell">Returns the arc sine of x.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="atan"></A>double atan( double x );</TD>
    <TD class="dunkel">Returns the arc tangens of x. Output between -PI/2 and 
      PI/2 (inclusive).</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="atan2"></A>double atan2( double x, double y );</TD>
    <TD class="hell">Returns the arc tangens of x/y. Also takes the signs of both 
      arguments into account when determinig the quadrant. Output between -PI 
      and PI (inclusive).</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="log"></A>double log( double x );</TD>
    <TD class="dunkel">Returns the natural logarithm of x.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="log10"></A>double log10( double x );</TD>
    <TD class="hell">Returns the logarithm of x to the base 10.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="pow"></A>double pow( double x, double y );</TD>
    <TD class="dunkel">Returns x^y.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="strtod"></A>double strtod( const char *s, char **endptr 
      );</TD>
    <TD class="hell">Converts an ASCII string to a double.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="square"></A>double square( double x );</TD>
    <TD class="dunkel">Returns x^2;</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="inverse"></A>double inverse( double x );</TD>
    <TD class="hell">Returns 1/x;</TD>
  </TR>
</TABLE>

<HR>

<A NAME="pgmspace.h"><H3>pgmspace.h</H3></A>

<P>
Another compatibility header file for the IAR C compiler. Contains (or is 
suposed to contain) things like memcpy_P, strcat_P, printf_P etc.
</P>
<P>
Since it's a compatibility header file, I chose not to document it. Yet.
</P>


<HR>

<A NAME="progmem.h"><H3>progmem.h</H3></A>

<P>
Includes <A HREF="#pgmspace.h">pgmspace.h</A>.
</P>


<HR>

<A NAME="setjmp.h"><H3>setjmp.h</H3></A>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="setjmp"></A>int setjmp( jmp_buf env 
      );</TD>
    <TD class="hell">Declares a longjmp-Target to be jumped at with longjmp (see 
      below.).</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="longjmp"></A>void longjmp( jmp_buf env, int val 
      );</TD>
    <TD class="dunkel">Executes a long jump to the position previously defined 
      with <tt>setjmp( 'env' )</tt>, which will return 'val'.</TD>
  </TR>
</TABLE>

<HR>

<A NAME="sig-avr.h"><H3>sig-avr.h</H3></A>

<P>
Defines symbols for the interrupt vectors that are stored at the begining of the 
flash memory. Defined are:
<P>
<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="SIG_INTERRUPT"></A>SIG_INTERRUPT0 through 
      SIG_INTERRUPT7</TD>
    <TD class="hell">Handler function name for the external interrupts 0 through 
      7. Interrupts > 1 are only available on certain ATmega AVRs.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_OUTPUT_COMPARE2"></A>SIG_OUTPUT_COMPARE2</TD>
    <TD class="dunkel">Handler function name for the Compare2 interrupt (Analog 
      Comparator).</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_OVERFLOW2"></A>SIG_OVERFLOW2</TD>
    <TD class="hell">Handler function name for the Overflow2 interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_INPUT_CAPTURE1"></A>SIG_INPUT_CAPTURE1</TD>
    <TD class="dunkel">Handler function name for the Capture1 interrupt.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_OUTPUT_COMPARE1A"></A>SIG_OUTPUT_COMPARE1A</TD>
    <TD class="hell">Handler function name for the Compare1(A) interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_OUTPUT_COMPARE1B"></A>SIG_OUTPUT_COMPARE1B</TD>
    <TD class="dunkel">Handler function name for the Compare1(B) interrupt.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_OVERFLOW1"></A>SIG_OVERFLOW1</TD>
    <TD class="hell">Handler function name for the Overflow1 interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_OUTPUT_COMPARE0"></A>SIG_OUTPUT_COMPARE0</TD>
    <TD class="dunkel">Handler function name for the Compare0 interrupt.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_OVERFLOW0"></A>SIG_OVERFLOW0</TD>
    <TD class="hell">Handler function name for the Overflow0 interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_SPI"></A>SIG_SPI</TD>
    <TD class="dunkel">Handler function name for the SPI interrupt.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_UART_RECV"></A>SIG_UART_RECV</TD>
    <TD class="hell">Handler function name for the UART(0) Receive Complete interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_UART1_RECV"></A>SIG_UART1_RECV</TD>
    <TD class="dunkel">Handler function name for the UART1 Receive Complete interrupt. 
      UART1 is only available on the ATmega161.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_UART_DATA"></A>SIG_UART_DATA</TD>
    <TD class="hell">Handler function name for the UART(0) Data Register Empty 
      interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_UART1_DATA"></A>SIG_UART1_DATA</TD>
    <TD class="dunkel">Handler function name for the UART1 Data Register Empty 
      interrupt. UART1 is only available on the ATmega161.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_UART_TRANS"></A>SIG_UART_TRANS</TD>
    <TD class="hell">Handler function name for the UART(0) Transmit Complete interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_UART1_TRANS"></A>SIG_UART1_TRANS</TD>
    <TD class="dunkel">Handler function name for the UART1 Transmit Complete interrupt. 
      UART1 is only available on the ATmega161.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_ADC"></A>SIG_ADC</TD>
    <TD class="hell">Handler function name for the ADC Comversion Complete interrupt.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="SIG_EEPROM"></A>SIG_EEPROM</TD>
    <TD class="dunkel">Handler function name for the EEPROM Ready interrupt.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="SIG_COMPARATOR"></A>SIG_COMPARATOR</TD>
    <TD class="hell">Handler function name for the Analog Comparator interrupt.</TD>
  </TR>
</TABLE>

<P>
Furthermore, the following functions/macros are defined:
</P>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="SIGNAL"></A>SIGNAL( signame );</TD>
    <TD class="hell">Used for defining an Signal handler for the signal 'signame'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="INTERRUPT"></A>INTERRUPT( signame );</TD>
    <TD class="dunkel">Used for defining an Interrupt handler for the signal 'signame'.</TD>
  <TR> 
</TABLE>
<p>In a handler defined
with SIGNAL(), additional interrupts are implicitly forbidden, whereas in an INTERRUPT()
handler, the first (implicit) instruction is "sei", so that additional interrupts can occur.</p>
<p>Thanks to J&ouml;rg Wunsch for correcting me there.</p>


<HR>

<A NAME="signal.h"><H3>signal.h</H3></A>

<P>
Includes <A HREF="#sig-avr.h">sig-avr.h</A>. You should use sig-avr.h directly, 
because signal.h might disappear shortly because it conflicts with the "real" 
ANSI C signal.h.
</P>


<HR>

<A NAME="stdlib.h"><H3>stdlib.h</H3></A>

<P>
Defines the following types:
</P>
<TT>typedef struct {<BR>
int quot;<BR>
int rem;<BR>
} div_t;<BR>
<BR>
typedef struct {<BR>
long quot;<BR>
long rem;<BR>
} ldiv_t;<BR>
<BR>
typedef int (*__compar_fn_t)(const void *, const void *);</TT><BR>
Used for comparison functions, eg. qsort().

<P>
Additionally, the following functions/macros are declared:
</P>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="abort"></A>void abort();</TD>
    <TD class="hell">Effectively aborts the execution by putting the MCU into 
      an endless loop.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="labs"></A>long labs( long x );</TD>
    <TD class="dunkel">Returns the absolute value of x.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="bsearch"></A>void *bsearch(const void *key, const 
      void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</TD>
    <TD class="hell">Performs a binary search on a sorted array.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="div"></A>div_t div( int x, int y );</TD>
    <TD class="dunkel">Divides x by y and returns the result (quotient and remainder) 
      in a div_t struct (see above).</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="ldiv"></A>ldiv_t ldiv( lomg x, long y );</TD>
    <TD class="hell">Divides x by y and returns the result (quotient and remainder) 
      in a ldiv_t struct (see above).</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="qsort"></A>void qsort(void *base, size_t nmemb, 
      size_t size, __compar_fn_t compar);</TD>
    <TD class="dunkel">Sorts an array at 'base' with 'nmemb' elements of size 
      'size', using the comparison function 'compar'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="strtol"></A>long strtol(const char *nptr, char **endptr, 
      int base);</TD>
    <TD class="hell">Converts the string at 'nptr' to a long integer according 
      to the base 'base'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="strtoul"></A>unsigned long strtoul(const char 
      *nptr, char **endptr, int base);</TD>
    <TD class="dunkel">Converts the string at 'nptr' to an unsigned long integer 
      according to the base 'base'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="atol"></A>long atol( char *p );</TD>
    <TD class="hell">Converts the string 'p' to a long integer.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="atoi"></A>long atoi( char *p );</TD>
    <TD class="dunkel">Converts the string 'p' to an integer.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="malloc"></A>void *malloc( size_t size );</TD>
    <TD class="hell">Allocates 'size' bytes of memory and returns a pointer to 
      it. Implemented, but not tested.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="free"></A>void free( void *ptr );</TD>
    <TD class="dunkel">Releases the memory at 'ptr', which was previously allocated 
      with malloc(). Implemented, but not tested.</TD>
  </TR>
  <TR> 
    <TD class="hell">double strtod( char *, char ** );</TD>
    <TD class="hell">See <A HREF="#strtod">math.h</A>.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="itoa"></A>char *itoa( int value, char *string, 
      int radix );</TD>
    <TD class="dunkel">Converts an integer into a string. This is not ANSI C, 
      but nonetheless (or maybe just because of this) very useful.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="ltoa"></A>char *ltoa( long value, char *string, 
      int radix );</TD>
    <TD class="hell">Converts a long into a string. Quite the same as itoa.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="ultoa"></A>char *ultoa( unsigned long value, char *string, 
      int radix );</TD>
    <TD class="dunkel">Converts an unsigned long into a string. See above.</TD>
  </TR>
</TABLE>

<P>
The following functions are not yet implemented:
</P>
<P>
<TT>atexit(), atof(), calloc(), rand(), realloc(), srand();</TT>
</P>


<HR>

<A NAME="string.h"><H3>string.h</H3></A>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="memccpy"></A>extern void *memccpy(void 
      *dest, const void *src, int c, size_t n);</TD>
    <TD class="hell">Copy at most 'n bytes from 'src' to 'dest' until character 
      'c' is found.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern void *memchr(const void *, int, size_t);</TD>
    <TD class="dunkel">Returns a pointer to the first occurence of 'c' in the
      first 'n' bytes of 's'.</TD>
  </TR>
  <TR> 
    <TD class="hell">extern int memcmp(const void *, const void *, size_t);</TD>
    <TD class="hell">Compare 'n' bytes of 's1' an 's2'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern void *memcpy(void *, const void *, size_t);</TD>
    <TD class="dunkel">Copy 'n' bytes from 'from' to 'to'.</TD>
  </TR>
  <TR> 
    <TD class="hell">extern void *memmove(void *dest, const void *src, size_t 
      n);</TD>
    <TD class="hell">Copy 'n' bytes of 'from' to 'to', guaranteeing correct 
      behavior for overlapping strings.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern void *memset(void *, int, size_t);</TD>
    <TD class="dunkel">Set 'n' bytes of 's' to 'c'.</TD>
  </TR>
  <TR> 
    <TD class="hell">extern char *strcat(char *, const char *);</TD>
    <TD class="hell">Append 'src' onto 'dest'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern char *strchr(const char *, int);</TD>
    <TD class="dunkel">Return a pointer to the first occurence of 'c' in 's'.</TD>
  </TR>
  <TR> 
    <TD class="hell">extern int strcmp(const char *, const char *);</TD>
    <TD class="hell">Compare 's1' and 's2'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern char *strcpy(char *, const char *);</TD>
    <TD class="dunkel">Copies 'src' intro 'dest'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="strcasecmp"></A>extern int strcasecmp(const char 
      *s1, const char *s2);</TD>
    <TD class="hell">Compare 's1' and 's2', ignoring case.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern size_t strlen(const char *);</TD>
    <TD class="dunkel">Returns the length of 's'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="strlwr"></A>extern char *strlwr(char *s);</TD>
    <TD class="hell">Converts all upper case characters in 's' to lower case.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern char *strncat(char *, const char *, size_t);</TD>
    <TD class="dunkel">Append no more than 'n' bytes from 'src' onto 'dest'.</TD>
  </TR>
  <TR> 
    <TD class="hell">extern int strncmp(const char *, const char *, size_t);</TD>
    <TD class="hell">Compare 'n' characters from 's1' and 's2'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern char *strncpy(char *, const char *, size_t);</TD>
    <TD class="dunkel">Copy no more than n bytes from 'src' to 'dest'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="strncasecmp"></A>extern int strncasecmp(const char 
      *, const char *, size_t);</TD>
    <TD class="hell">Compare 'n' bytes of 's1' and 's2', ignoring case.</TD>
  </TR>
  <TR> 
    <TD class="dunkel">extern size_t strnlen(const char *, size_t);</TD>
    <TD class="dunkel">Returns the length of 's', but at most 'maxlen'.</TD>
  </TR>
  <TR> 
    <TD class="hell">extern char *strrchr(const char *, int);</TD>
    <TD class="hell">Return a pointer to the last occurence of 'c' in 's'.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="strrev"></A>extern char *strrev(char *s1);</TD>
    <TD class="dunkel">Reverses 's1'.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="strstr"></A>extern char *strstr(const char *haystack, 
      const char *needle);</TD>
    <TD class="hell">Locate 'needle' in 'haystack', and return a pointer to it.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="strupr"></A>extern char *strupr(char *s);</TD>
    <TD class="dunkel">Converts all lower case characters in 's' to upper case.</TD>
  </TR>
</TABLE>


<HR>

<A NAME="timer.h"><H3>timer.h</H3></A>

<P>
Defines an enumeration for the Timer Control Register:
</P>

<TT>enum {<BR>
STOP             = 0,<BR>
CK               = 1,<BR>
CK8              = 2,<BR>
CK64             = 3,<BR>
CK256            = 4,<BR>
CK1024           = 5,<BR>
T0_FALLING_EDGE  = 6,<BR>
T0_RISING_EDGE   = 7<BR>
};<BR>
</TT>

<P>
And there are the following functions:
<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="timer0_source"></A>void timer0_source( 
      unsigned int src );</TD>
    <TD class="hell">Writes 'src' into the TCCR0 register.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="timer0_stop"></A>void timer0_stop();</TD>
    <TD class="dunkel">Stops Timer 0 by clearing the TCNT0 register.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="timer0_start"></A>coid timer0_start();</TD>
    <TD class="hell">Starts Timer 0 by writing a 1 into the TCNT0 register.</TD>
  </TR>
</TABLE>


<HR>

<A NAME="twi.h"><H3>twi.h</H3></A>

<P>
Defines several constants for the ATmega163.
</P>


<HR>

<A NAME="wdt.h"><H3>wdt.h</H3></A>

<TABLE WIDTH="80%" ALIGN="CENTER" BORDER="0">
  <TR> 
    <TD WIDTH="30%" class="hell"><A NAME="wdt_reset"></A>wdt_reset();</TD>
    <TD class="hell">Resets the Watchdog Timer.</TD>
  </TR>
  <TR> 
    <TD class="dunkel"><A NAME="wdt_enable"></A>wdt_enable( timeout );</TD>
    <TD class="dunkel">Enables the Watchdog Timer with timeout 'timeout'. For 
      the actual timeout value, refer to the Atmel AVR datasheets.</TD>
  </TR>
  <TR> 
    <TD class="hell"><A NAME="wdt_disable"></A>wdt_disable();</TD>
    <TD class="hell">Disables the Watchdog Timer.</TD>
  </TR>
</TABLE>

</BODY>
</HTML>

